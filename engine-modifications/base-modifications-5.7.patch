diff --git a/Engine/Source/Developer/UbaCoordinatorHorde/Private/UbaHordeAgentManager.cpp b/Engine/Source/Developer/UbaCoordinatorHorde/Private/UbaHordeAgentManager.cpp
index 73d80f7de3e3..da1fbe12a71f 100644
--- a/Engine/Source/Developer/UbaCoordinatorHorde/Private/UbaHordeAgentManager.cpp
+++ b/Engine/Source/Developer/UbaCoordinatorHorde/Private/UbaHordeAgentManager.cpp
@@ -455,7 +455,7 @@ void FUbaHordeAgentManager::ThreadAgent(FHordeAgentWrapper& Wrapper)
 
 		if (bUseListen)
 		{
-			UbaAgentArgs.Add(FAnsiString::Printf("-Listen=%u", UbaPort.AgentPort));
+			UbaAgentArgs.Add(FAnsiString::Printf("-Listen=%u", Agent->GetMachineInfo().UbaListenPort));
 			UbaAgentArgs.Add(TEXT("-ListenTimeout=10"));
 		}
 		else
@@ -487,6 +487,11 @@ void FUbaHordeAgentManager::ThreadAgent(FHordeAgentWrapper& Wrapper)
 		UbaAgentArgs.AddRaw("-Eventfile=%UE_HORDE_TERMINATION_SIGNAL_FILE%");
 		UbaAgentArgs.Add(FAnsiString::Printf("-Description=%s", TCHAR_TO_ANSI(*Agent->GetMachineInfo().LeaseLink)));
 
+		UbaAgentArgs.AddRaw("-MaxCpu=%UE_HORDE_CPU_COUNT%");
+		UbaAgentArgs.AddRaw("-MulCpu=%UE_HORDE_CPU_MULTIPLIER%");
+		UbaAgentArgs.AddRaw("-MaxCon=8");
+		UbaAgentArgs.AddRaw("-MaxWorkers=64");
+
 		UbaAgentArgs.Finalize();
 
 		// If the machine does not run Windows, enable the compatibility layer Wine to run UbaAgent.exe on POSIX systems
diff --git a/Engine/Source/Developer/UbaCoordinatorHorde/Private/UbaHordeMetaClient.cpp b/Engine/Source/Developer/UbaCoordinatorHorde/Private/UbaHordeMetaClient.cpp
index 522a683f7e68..0eadee62e2ab 100644
--- a/Engine/Source/Developer/UbaCoordinatorHorde/Private/UbaHordeMetaClient.cpp
+++ b/Engine/Source/Developer/UbaCoordinatorHorde/Private/UbaHordeMetaClient.cpp
@@ -281,6 +281,11 @@ TSharedPtr<FUbaHordeMetaClient::HordeMachinePromise, ESPMode::ThreadSafe> FUbaHo
 
 			uint16 LogicalCores = 0;
 			uint16 PhysicalCores = 0;
+			FString NonceString = NonceValue->AsString();
+			FString IpString = IpValue->AsString();
+			uint16 PortNumber = (uint16)PortValue->AsNumber();
+			uint16 UbaListenPortNumber = 7001;
+			uint16 UbaExposedPortNumber = UbaListenPortNumber;
 
 			if (TSharedPtr<FJsonValue> PropertiesValue = OutJson->AsObject()->TryGetField(TEXT("properties")))
 			{
@@ -304,6 +309,18 @@ TSharedPtr<FUbaHordeMetaClient::HordeMachinePromise, ESPMode::ThreadSafe> FUbaHo
 					{
 						PhysicalCores = (uint16)FCString::Atoi(*PropertyElementString + 14);
 					}
+					if (PropertyElementString.StartsWith(TEXT("ExposedComputePort=")))
+					{
+						PortNumber = (uint16)FCString::Atoi(*PropertyElementString + 19);
+					}
+					if (PropertyElementString.StartsWith(TEXT("UbaPort=")))
+					{
+						UbaListenPortNumber = (uint16)FCString::Atoi(*PropertyElementString + 8);
+					}
+					if (PropertyElementString.StartsWith(TEXT("ExposedUbaPort=")))
+					{
+						UbaExposedPortNumber = (uint16)FCString::Atoi(*PropertyElementString + 15);
+					}
 				}
 			}
 
@@ -320,14 +337,11 @@ TSharedPtr<FUbaHordeMetaClient::HordeMachinePromise, ESPMode::ThreadSafe> FUbaHo
 				Info.LogicalCores = 16; // Wild guess
 			}
 
-			// Log summary of assigned Horde machine
-			FString NonceString = NonceValue->AsString();
-			FString IpString = IpValue->AsString();
-			uint16 PortNumber = (uint16)PortValue->AsNumber();
-
 			// Return final response information
 			Info.Ip = IpString;
 			Info.Port = PortNumber;
+			Info.UbaListenPort = UbaListenPortNumber;
+			Info.UbaExposedPort = UbaExposedPortNumber;
 			FString::ToHexBlob(NonceString, Info.Nonce, HORDE_NONCE_SIZE);
 
 			TStringBuilder<512> HordeMachineSummary;
diff --git a/Engine/Source/Developer/UbaCoordinatorHorde/Private/UbaHordeMetaClient.h b/Engine/Source/Developer/UbaCoordinatorHorde/Private/UbaHordeMetaClient.h
index 8919652bf397..d4841847705b 100644
--- a/Engine/Source/Developer/UbaCoordinatorHorde/Private/UbaHordeMetaClient.h
+++ b/Engine/Source/Developer/UbaCoordinatorHorde/Private/UbaHordeMetaClient.h
@@ -40,6 +40,8 @@ struct FHordeRemoteMachineInfo
 	EUbaHordeConnectionMode ConnectionMode = EUbaHordeConnectionMode::Direct;
 	FString ConnectionAddress; // Onyl used for relay mode
 	uint16 Port = 0;
+	uint16 UbaListenPort = 0;
+	uint16 UbaExposedPort = 0;
 	TMap<FString, FPortInfo> Ports; // Maps compute service names to port/agent-port pairs, e.g. "_horde_compute" -> {Port: 12345, AgentPort: 7000}
 	uint16 LogicalCores = 0;
 	EUbaHordeEncryption Encryption = EUbaHordeEncryption::None;
diff --git a/Engine/Source/Programs/Shared/EpicGames.Horde/Compute/Clients/ServerComputeClient.cs b/Engine/Source/Programs/Shared/EpicGames.Horde/Compute/Clients/ServerComputeClient.cs
index 87556727bcc8..35c383152666 100644
--- a/Engine/Source/Programs/Shared/EpicGames.Horde/Compute/Clients/ServerComputeClient.cs
+++ b/Engine/Source/Programs/Shared/EpicGames.Horde/Compute/Clients/ServerComputeClient.cs
@@ -404,7 +404,28 @@ namespace EpicGames.Horde.Compute.Clients
 				switch (response.ConnectionMode)
 				{
 					case ConnectionMode.Direct:
-						await socket.ConnectAsync(connectionAddress.host, connectionAddress.port, cancellationToken);
+						int ComputePort = response.Port;
+
+						foreach (string property in response.Properties)
+						{
+							int equalsIdx = property.IndexOf('=', StringComparison.OrdinalIgnoreCase);
+							StringView propertyName = new(property, 0, equalsIdx);
+
+							if (propertyName == "ExposedComputePort")
+							{
+								if (!Int32.TryParse(property.AsSpan(equalsIdx + 1), out ComputePort))
+								{
+									workerLogger.LogError("Failed to parse ExposedComputePort property: {Property}", property);
+								}
+								else
+								{
+									agentAddress.host = response.Ip;
+									agentAddress.port = ComputePort;
+								}
+							}
+						}
+
+						await socket.ConnectAsync(IPAddress.Parse(response.Ip), ComputePort, cancellationToken);
 						break;
 
 					case ConnectionMode.Tunnel when !String.IsNullOrEmpty(response.ConnectionAddress):
diff --git a/Engine/Source/Programs/UnrealBuildTool/Executors/UnrealBuildAccelerator/UBAAgentCoordinatorHorde.cs b/Engine/Source/Programs/UnrealBuildTool/Executors/UnrealBuildAccelerator/UBAAgentCoordinatorHorde.cs
index b8bd4a0407c8..417f048063bd 100644
--- a/Engine/Source/Programs/UnrealBuildTool/Executors/UnrealBuildAccelerator/UBAAgentCoordinatorHorde.cs
+++ b/Engine/Source/Programs/UnrealBuildTool/Executors/UnrealBuildAccelerator/UBAAgentCoordinatorHorde.cs
@@ -269,6 +269,10 @@ namespace UnrealBuildTool
 				"EC2",
 				"LeaseId",
 				"aws-instance-type",
+				"UbaPort",
+				"ExposedUbaPort",
+				"UbaProxyPort",
+				"ExposedUbaProxyPort",
 			};
 
 		public async Task<bool> AddWorkerAsync(Requirements requirements, UnrealBuildAcceleratorHordeConfig hordeConfig, CancellationToken cancellationToken, int activeCores)
@@ -284,8 +288,10 @@ namespace UnrealBuildTool
 
 			const string UbaPortName = "UbaPort";
 			const string UbaProxyPortName = "UbaProxyPort";
-			const int UbaPort = 7001;
-			const int UbaProxyPort = 7002;
+			int UbaPort = 7001;
+			int UbaProxyPort = 7002;
+			int ExposedUbaPort = UbaPort;
+			int ExposedUbaProxyPort = UbaProxyPort;
 
 			// Request ID that is unique per attempt to acquire the same compute lease/worker
 			// Primarily for tracking worker demand on Horde server as UBAExecutor will repeatedly try adding a new worker
@@ -315,6 +321,16 @@ namespace UnrealBuildTool
 
 				++_workerId;
 
+				if (!lease.Ports.TryGetValue(UbaPortName, out ConnectionMetadataPort? ubaPort))
+				{
+					ubaPort = new ConnectionMetadataPort(UbaPort, UbaPort);
+				}
+
+				if (!lease.Ports.TryGetValue(UbaProxyPortName, out ConnectionMetadataPort? ubaProxyPort))
+				{
+					ubaProxyPort = new ConnectionMetadataPort(UbaProxyPort, UbaProxyPort);
+				}
+
 				workerLogger.LogDebug("Agent properties:");
 
 				string agentName = String.Empty;
@@ -322,6 +338,10 @@ namespace UnrealBuildTool
 				string computeIp = String.Empty;
 				string leaseId = string.Empty;
 				string instanceType = string.Empty;
+				UbaPort = ubaPort.AgentPort;
+				ExposedUbaPort = ubaPort.Port;
+				UbaProxyPort = ubaProxyPort.AgentPort;
+				ExposedUbaProxyPort = ubaProxyPort.Port;
 				foreach (string property in lease.Properties)
 				{
 					int equalsIdx = property.IndexOf('=', StringComparison.OrdinalIgnoreCase);
@@ -350,9 +370,28 @@ namespace UnrealBuildTool
 						{
 							instanceType = property[(equalsIdx + 1)..];
 						}
+						else if (propertyName == "UbaPort")
+						{
+							Int32.TryParse(property.AsSpan(equalsIdx + 1), out UbaPort);
+						}
+						else if (propertyName == "ExposedUbaPort")
+						{
+							Int32.TryParse(property.AsSpan(equalsIdx + 1), out ExposedUbaPort);
+						}
+						else if (propertyName == "UbaProxyPort")
+						{
+							Int32.TryParse(property.AsSpan(equalsIdx + 1), out UbaProxyPort);
+						}
+						else if (propertyName == "ExposedUbaProxyPort")
+						{
+							Int32.TryParse(property.AsSpan(equalsIdx + 1), out ExposedUbaProxyPort);
+						}
 					}
 				}
 
+				ubaPort = new ConnectionMetadataPort(ExposedUbaPort, UbaPort);
+				ubaProxyPort = new ConnectionMetadataPort(ExposedUbaProxyPort, UbaProxyPort);
+
 				string desc = instanceType;
 				if (!String.IsNullOrEmpty(leaseId))
 				{
@@ -362,16 +401,6 @@ namespace UnrealBuildTool
 				// When using relay connection mode, the IP will be relay server's IP
 				string ip = String.IsNullOrEmpty(lease.Ip) ? computeIp : lease.Ip;
 
-				if (!lease.Ports.TryGetValue(UbaPortName, out ConnectionMetadataPort? ubaPort))
-				{
-					ubaPort = new ConnectionMetadataPort(UbaPort, UbaPort);
-				}
-
-				if (!lease.Ports.TryGetValue(UbaProxyPortName, out ConnectionMetadataPort? ubaProxyPort))
-				{
-					ubaProxyPort = new ConnectionMetadataPort(UbaProxyPort, UbaProxyPort);
-				}
-
 				string exeName = OperatingSystem.IsWindows() ? "UbaAgent.exe" : "UbaAgent";
 				BlobLocator locator = _ubaAgentLocator;
 				Worker worker = new()
